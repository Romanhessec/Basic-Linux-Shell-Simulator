/*323CBb, Roman Gabriel - Marian*/

	Pentru inceput, pentru citirea datelor ma folosesc de o bucla de tipul while(1)
si functiile strstr, strtok; De mentionat aici este partea cu rm/rmdir, unde
am intercalat cele doua if-uri deoarece strstr-ul raspundea din prima la "rm"
si nu mai verifica mai incolo daca era vorba despre "rmdir";

	In implementare, m-am folosit si de functiile allocDir() si allocFile(), unde
alochez memoria si informatiile necesare pentru dir/fisier.
	
1. Touch:
	- pentru inceput, aloc fisierul folosind functia allocFile mentionata mai sus,
urmand ca mai apoi sa verific daca parent dir-ul are head-ul gol, caz in care pun
direct file-ul acolo; in caz contrar, o iau pe lista, verific mereu daca nu mai
exista cumva vreun fisier cu acelasi nume, si, daca ajung la final, lipesc fisierul
deoarece am siguranta ca numele este unic in lista - toate acestea nu inainte de
a verifica si daca numele fisierului se afla in lista de head_dirs;

2. mkdir:
	- face exact acelasi lucru ca si touch, numai ca pentru dir-uri; nu cred ca
are rost sa mai iterez pasii;

3. ls:
	- pentru ls, iterez mai intai prin lista de Dir-uri, afisand mereu numele 
dir-ului curent, iar apoi repet acelasi algoritm si pentru lista de files a 
directorului parinte (currentDir) trimis ca argument;

4. rm:
	- initial, verific daca lista de fisiere este goala (caz marginas);
	- procesul urmator este unul clasic de stergere a unei celule dintr-o lista,
invatat la CD; interez cu doi pointeri, toIterate si toIteratePrev, si cand gasesc
fisierul cautat, ma ocup de stergere, avand grija sa refac legaturile intre celule;

5. rmdir:
	- acelasi scenariu ca la mkdir, face acelasi algoritm ca si rm, numai ca pentru
dir-uri; nu o sa mai iterez pasii din nou;

6. cd:
	- initial, pun in toIterateDirs head-ul de dirs a fisierului target, pentru a  
putea itera ulterior cu ajutorul sau;
	- in continuare, verific cazul "cd .."; daca acesta a fost inputul, fac noul
dir curent (currentDir) (*target)->parent;
	- restul algoritmului verifica restul listei din toIterateDirs; daca gaseste
numele din cd <name>, modifica currentDir, altfel afiseaza mesajul corespunzator;

7. pwd:
	- intuitia imi spune ca ideea developerilor ar fi fost sa folosim recursivitate
si aici, insa cum mi-a venit initial alta idee, am mers cu asta si am dus-o pana
la capat pe modul horse-view :D;
	- initial, calculez levelul pe care se afla directorul curent (level pornind
de la /home);
	- dupa care, folosind acel toPrint, merg de la cap la capat, pana in currentDir,
folosindu-ma de acel level pentru bucla for si de strcat pentru a completa iterativ
toPrint-ul;

8. tree:
	- initial, in functie de level, fac un string "spaces" pentru a stoca cate 
spatii trebuie sa printez, dupa care fac un strcat, pun numele dir-ului, si trec
mai departe in conditiile de recursivitate;
	- pentru urmatorii pasi, am folosit in cod niste comentarii if<1,4> pentru a
urmari cu mai multa usurinta recursivitatea;
	- in if1, verific urmatoarea cea mai puternica conditie, respectiv merg in 
head-ul de directoare (acel int level2 = level1 e folosit pentru a-mi pastra nr.
de nivele corect pe lantul de recursivitate);
	- pt if2, verific head-ul de fisiere; tot aici, m-am folosit si de o alta functie
ajutatoare, printTreeFiles, care, in a nutshell, face acelasi lucru ca si tree,
numai ca mult mai simplificat (respectiv, calculez numarul de spatii prin acelasi
mod ca si la tree, diferenta reprezentand-o faptul ca, la if-urile pentru a merge pe
recursivitate, nu verific decat daca mai exista un fisier->next, pentru a-l printa si 
pe el);
	- if3-ul merge pe urmatoarea conditie importanta, respectiv daca mai exista dir-uri
urmatoare, cu acelasi parinte (target->next);
	- if4-ul reprezinta o atrocitate facuta deoarece, in main, eu la functia tree dau
ca parametru pentru director currentDir->head_children_dirs; am facut acest lucru 
initial pentru a nu printa si /home (lucru care mi se intampla); problema acestei
implementari este ca nu imi printa si fisiere din directorul home; astfel, am 
fost nevoit sa fac if-ul 4, care verifica daca dir-ul parinte e home si daca are
fisiere de printat, caz in care ma folosesc iarasi de printTreeFiles; mi-am promis
ca o sa modific implementarea ulterior, but here i am :D;

9. stop:
	- dealoca memoria (daca am facut asta), urmand ca in main sa dau break-ul care
ma scoate din main si imi termina programul;

10. mv:
	- pentru implementare/iterare, ma voi folosi de doi iteratori (toIterateDirs 
si toIterateFiles), care pornesc ambii din head-ul corespunzator al dir-ului 
parent;
	- avand in vedere ca nu stiu ce tip de date primesc la mv (file sau dir), am
fost nevoit sa verific ambele cazuri in cod; astfel, primul while se ocupa de 
verificare dir-urilor, urmand ca cel de-al doilea sa se ocupe de cazul fisierelor;
avand in vedere ca implementarea este identica, exceptand schimbarile ce tin de 
tipul datelor (in loc de allocDir() alocFile(), sau in loc de Dir*, File*), am
sa descriu doar while-ul pentru verificarea dir-urilor;
	- pentru conditia de iesire din while (fiindca, trebuie mentionat, folosesc
din nou un while (1)), verific daca toIterateDirs == NULL, caz in care, evident,
dau break;
	- in continuare, verific, la fiecare iteratie, daca exista oldname; daca 
exista, merg pe acel if, care reprezinta si marea majoritate din functie;
	- acest if verifica, pentru inceput, daca nu cumva newname-ul dat exista
deja, folosindu-se de functia checkIfNewnameExists (functia este extrem de 
banala, nu face altceva decat sa itereze prin toate dir-urile si fisierele
dir-ului parinte si sa returneze 0 daca gaseste newname-ul, si 1 daca nu il 
gaseste - check the comms);
	- daca newname-ul exista deja, printam ce trebuie si iesim din functie;
	- daca newname-ul nu exista, totul e ok si putem face mv-ul propriu zis;
astfel, alloc un nou fisier toMoveDir cu toate informatiile din toIterateDirs
(pointer care retine dir-ul cu oldname, practic dir-ul care trebuie mutat),
sterg cu rmdir dir-ul cu oldname, si pun in continuare toMoveDir (nu am putut
folosi aici mkdir deoarece dir-ul toMoveDir are si caracteristici speciale,
precum fisiere proprii sau diruri proprii, deci trebuia o implementare mai
specifica); 
	- daca nu gaseste oldname deloc in nicio iteratie, se duce sa verifice pe
al doilea while (cel pentru fisiere), while care, asa cum am precizat, face
exact acelasi lucru ca si primul, deci nu am sa mai iterez prin el;
	- in final, daca trece de ambele while-uri, mv-ul nu a gasit oldname nici
dir, nici ca fisier, deci nu ramane decat sa printeze ("File/Director not found")
 si sa treaca mai departe;



